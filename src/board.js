export class Board {
  constructor(numberOfRows, numberOfColumns, numberOfBombs){
      this._numberOfBombs = numberOfBombs;
      // numberOfTiles = number of LIVE tiles not yet flipped
      this._numberOfTiles = numberOfRows * numberOfColumns;
      this._playerBoard = Board.generatePlayerBoard(numberOfRows, numberOfColumns);
      this._bombBoard = Board.generateBombBoard(numberOfRows, numberOfColumns, numberOfBombs);
                              //generateBombBoard
  }
  
  get playerBoard(){
    return this._playerBoard;
  }
  
  //used to be flipTile = (rowIndex, columnIndex) => {
  flipTile(rowIndex, columnIndex){
    if(this._playerBoard[rowIndex][columnIndex] != ' ')
    {
      console.log("This tile has already been flipped!")
      return;
    }
    else if (this._bombBoard[rowIndex][columnIndex] === 'B')
    {
        this._playerBoard[rowIndex][columnIndex] = 'B';
    }
    else
    {
      this._playerBoard[rowIndex][columnIndex] = this.getNumberOfNeighborBombs(
      rowIndex, columnIndex);
    }
    this._numberOfTiles--;  
  }
  
  // This was hard - but I got it nowjava
  getNumberOfNeighborBombs(rowIndex, columnIndex) {
    const neighborOffsets = [
      [-1, -1], [-1, 0], [-1, 0],
      [0, -1], [0, 1],
      [1, -1], [1, 0], [1, 1]
    ];
  
    const numberOfRows = this._bombBoard.length; 
    /* because the board generated by 
    generateBombBoard is a 2D array - the first layer of array values = # of rows */
    const numberOfColumns = this._bombBoard[0].length; // how many values in first row
    let numberOfBombs = 0;
  
    /* this runs on EVERY element in the array, aka [1, -1] is ONE element.
    The first parameter in foreach(), aka offset here, represents the 
    current element in the array that foreach() is iterating through. 
    rowIndex and columnIndex is the row/column of the tile the player's flipping. */
    neighborOffsets.forEach(offset => {
      
      /* offset[0] means the row offset, offset[1] means the column offset,
      because each element in the neighborOffsets array has 2 elements (aka [-1, -1]). */
      const neighborRowIndex = rowIndex + offset[0];
      const neighborColumnIndex = columnIndex + offset[1]; 
      
      // check if the neighbor cell selected is off the board or not
      if(neighborRowIndex >= 0 && neighborRowIndex < numberOfRows &&
        neighborColumnIndex >= 0 && neighborColumnIndex < numberOfColumns)
        {
          if(this._bombBoard[neighborRowIndex][neighborColumnIndex] === 'B')
          {
            numberOfBombs++;
          }
        }
    }); // this ends the parameters for the forEach() method
    return numberOfBombs;
  } // end getNumberOfNeighborBombs method
  
  hasSafeTiles(){
    return this._numberOfTiles != this._numberOfBombs;
      
  }
  
  /* Instructions say to Make sure to reference instance properties 
  using this and underscores (this should be a matter of simply adding 
  this to existing variable names in the function, like playerBoard) */
  print() {
    console.log(this._playerBoard.map(row => row.join(' | ')).join('\n'));
  }
  
  /* original print() method
  print(printInput) {
    console.log(printInput.map(row => row.join(' | ')).join('\n'));
  }
  */
  
  static generatePlayerBoard(numberOfRows, numberOfColumns)
  {
    let board = [];
    for (let rowCounter = 0; rowCounter < numberOfRows; rowCounter++)
    {
      let row = [];
      for (let colCounter = 0; colCounter < numberOfColumns; colCounter++)
      {
        row.push(' ');
      }
      board.push(row);
  
    } // row generator
    return board;
  } // end generatePlayerBoard method
  
  // originally NOT static, was getting error that it wasn't a function
  static generateBombBoard(numberOfRows, numberOfColumns, numberOfBombs) 
  {
    let board = [];
    // fill in the first row with empty values, then repeat
    for (let rowCounter = 0; rowCounter < numberOfRows; rowCounter++)
    {
      let row = [];
      // fill in each cell in the current row.  when row is full, exit this
      for (let colCounter = 0; colCounter < numberOfColumns; colCounter++)
      {
        row.push(null);
      }
      board.push(row);
  
    } // row generator
    let numberOfBombsPlaced = 0;
    while(numberOfBombsPlaced < numberOfBombs)
    {
      let randomRowIndex = Math.floor(Math.random() * numberOfRows);
      let randomColIndex = Math.floor(Math.random() * numberOfColumns);
      if(board[randomRowIndex][randomColIndex] != 'B')
      {
        board[randomRowIndex][randomColIndex] = 'B';
        numberOfBombsPlaced++;
      }
  
    }
    return board;
  } // end generateBombBoard method

} // end Board class